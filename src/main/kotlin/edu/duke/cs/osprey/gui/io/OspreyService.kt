package edu.duke.cs.osprey.gui.io

import edu.duke.cs.osprey.Osprey
import edu.duke.cs.osprey.service.Point3d
import edu.duke.cs.osprey.service.ResponseInfo
import edu.duke.cs.osprey.service.ServiceResponse
import edu.duke.cs.osprey.service.services.*
import io.ktor.client.HttpClient
import io.ktor.client.engine.apache.*
import io.ktor.client.features.json.JsonFeature
import io.ktor.client.request.HttpRequestBuilder
import io.ktor.client.request.request
import io.ktor.http.*
import org.apache.http.conn.ssl.TrustSelfSignedStrategy
import org.apache.http.ssl.SSLContextBuilder
import org.joml.Vector3d
import java.security.cert.X509Certificate
import javax.naming.ldap.LdapName
import javax.net.ssl.SSLPeerUnverifiedException
import javax.security.auth.x500.X500Principal


object OspreyService {

	val version: String =
		Osprey.versionService

	private val client =
		HttpClient(Apache) {
			install(JsonFeature) {
				serializer = edu.duke.cs.osprey.service.OspreyService.serializer
			}
			engine {

				// some requests can take a long time, so disable timeouts
				socketTimeout = 0

				customizeClient {

					// trust self-signed certificates, which are generated by installations of Osprey service
					setSSLContext(SSLContextBuilder()
						.loadTrustMaterial(TrustSelfSignedStrategy())
						.build())

					// check that the SSL certificate actually says it's for the Osprey service
					// the distinguished name for the issuer should look something like this:
					// EMAILADDRESS=osprey@cs.duke.edu, CN=osprey.service, O=Osprey
					// NOTE: we don't actually verify the hostname here, since we're only using SSL
					// for in-flight encryption, not host identity management

					/*
					setSSLHostnameVerifier { hostname, session ->

						val distinguishedName = session.peerCertificates
							.filterIsInstance<X509Certificate>()
							.firstOrNull()
							?.issuerX500Principal
							?.getName(X500Principal.RFC2253)
							?.let { LdapName(it) }
							?: run {
								throw SSLPeerUnverifiedException("""
									|Rejected SSL connection to $hostname because no issuer for certificate could be found
								""".trimMargin())
							}

						val commonName = distinguishedName.rdns.find { it.type == "CN" }?.value
						if (commonName != "osprey.service") {
							throw SSLPeerUnverifiedException("""
								|Rejected SSL connection to $hostname because certificate was not issued by Osprey
								|  Issuer: $distinguishedName
							""".trimMargin())
						}

						// if we got here, all is well
						true
					}
					*/
				}
			}
		}

	/**
	 * Used to temporarily override the service provider defined by the user settings.
	 * Useful for running a local service without permanently changing user settings.
	 */
	var provider: UserSettings.ServiceProvider? = null

	private fun HttpRequestBuilder.path(path: String) {
		url {
			val provider = provider ?: UserSettings.serviceProvider
			host = provider.hostname
			port = provider.port
			path("v$version/$path")
			protocol = when (provider.https) {
				false -> URLProtocol.HTTP
				true -> URLProtocol.HTTPS
			}
		}
	}

	private suspend inline fun <reified R:ResponseInfo> get(path: String) =
		client.request<ServiceResponse<R>> {
			path(path)
			method = HttpMethod.Get
		}
		.responseOrThrow()

	private suspend inline fun <reified R:ResponseInfo> post(path: String, arg: Any) =
		client.request<ServiceResponse<R>> {
			path(path)
			method = HttpMethod.Post
			contentType(ContentType.Application.Json)
			body = arg
		}
		.responseOrThrow()


	suspend fun about() =
		get<AboutResponse>("about")

	suspend fun missingAtoms(request: MissingAtomsRequest) =
		post<MissingAtomsResponse>("missingAtoms", request)

	suspend fun bonds(request: BondsRequest) =
		post<BondsResponse>("bonds", request)

	suspend fun protonation(request: ProtonationRequest) =
		post<ProtonationResponse>("protonation", request)

	suspend fun protonate(request: ProtonateRequest) =
		post<ProtonateResponse>("protonate", request)

	suspend fun types(request: TypesRequest) =
		post<TypesResponse>("types", request)

	suspend fun moleculeFFInfo(request: MoleculeFFInfoRequest) =
		post<MoleculeFFInfoResponse>("moleculeFFInfo", request)

	suspend fun forcefieldParams(request: ForcefieldParamsRequest) =
		post<ForcefieldParamsResponse>("forcefieldParams", request)

	suspend fun minimize(request: MinimizeRequest) =
		post<MinimizeResponse>("minimize", request)

	suspend fun clashes(request: ClashesRequest) =
		post<ClashesResponse>("clashes", request)
}


fun Point3d.toVector3d() = Vector3d(x, y, z)
